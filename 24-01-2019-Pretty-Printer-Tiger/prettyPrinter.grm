(* This is the preamble where you can have arbitrary sml code. For us
it is empty *)

%%

(* Name of the parser *)
%name PrettyPrinter

(* Produces verbose description of the generated LALR parser *)
%verbose

(* type to capture the position of a token within a file *)
%pos int

(* The terminals or tokens of the language.
   Similar to ML datatype declaration.
   The terminals with no datatype have no value associated with them *)
%term INTEGER of int
    | ID of string
    | STRING of string
    | COMMENT of string
    | ARRAY
    | BREAK
    | DO
    | ELSE
    | END
    | FOR
    | FUNCTION
    | IF
    | IN
    | LET
    | NIL
    | OF
    | THEN
    | TO
    | TYPE
    | VAR
    | WHILE
    | NOTEQUAL
    | LESSEQUAL
    | GREATEREQUAL
    | ASSIGN
    | LPAREN
    | RPAREN
    | LBRACES
    | RBRACES
    | LBRACKETS
    | RBRACKETS
    | COLON
    | DOT
    | SEMICOLON
    | COMMA
    | PLUS
    | MINUS
    | EQUALS
    | MULTIPLY
    | DIVIDE 
    | LESS
    | GREATER
    | AND
    | OR
    | EOF
    
(* The nonterminals or symbols of the language.
   The types for the nonterminals are the correspoding abstract syntax used to capture the semantic 
   meaning of the values associated with the nonterminal *)
%nonterm PROGRAM                of Ast.Program
       | EXP                    of Ast.Exp
       | EXPS                   of Ast.Exp list
       | LVALUE                 of Ast.Lvalue
       | RECORDFIELDDEC         of (string * Ast.Exp) list
       | RECORDFIELDCREATE      of (string * string) list
       | DECS                   of Ast.Decs
       | TYPEDEC                of Ast.TypeDec
       | FUNDEC                 of Ast.FunDec
       | VARDEC                 of Ast.VarDec
       | OPERATOR               of Ast.Operator

%eop EOF                (* the set of terminals that may follow the start symbol *)
%pure                   (* the semantic actions are free of significant side-effects and always terminate *)
%noshift EOF            (* non-shiftable terminals *)
%arg (fileName) : string


(* Specifying the precedence and associativity of operators *)
%left OR
%left AND 
%nonassoc GREATEREQUAL LESSEQUAL EQUALS NOTEQUAL LESS GREATER
%left PLUS MINUS
%left MULTIPLY DIVIDE
%left ASSIGN

%%

(* The grammar associated with our program *)
PROGRAM : EXP                                       ( EXP )

EXP     : NIL                                       ( Ast.Nil )
        | INTEGER                                   ( Ast.Integer INTEGER )
        | STRING                                    ( Ast.String STRING )
        | LVALUE                                    ( Ast.Lval LVALUE ) 
        | MINUS EXP                                 ( Ast.Negation EXP ) 
        | LPAREN EXPS RPAREN                        ( Ast.Exps EXPS )
        | LPAREN RPAREN                             ( Ast.Exps nil )
        | ID LPAREN EXPS RPAREN                     ( Ast.FunCall (ID, EXPS) )
        | ID LPAREN RPAREN                          ( Ast.FunCall (ID, nil) )
        | EXP OPERATOR EXP                          ( Ast.App (EXP1, OPERATOR, EXP2) )
        | ID LBRACKETS EXP RBRACKETS OF EXP         ( Ast.Array (ID, EXP1, EXP2) )
        | ID LBRACES RECORDFIELDDEC RBRACES         ( Ast.Record (ID, RECORDFIELDDEC) )
        | LVALUE ASSIGN EXP                         ( Ast.Assignment (LVALUE, EXP) )
        | IF EXP THEN EXP ELSE EXP                  ( Ast.IfThenElse (EXP1, EXP2, EXP3) )
        | IF EXP THEN EXP                           ( Ast.IfThen (EXP1, EXP2) )
        | WHILE EXP DO EXP                          ( Ast.While (EXP1, EXP2) )
        | FOR ID ASSIGN EXP TO EXP DO EXP           ( Ast.For (ID, EXP1, EXP2, EXP3) )
        | LET DECS IN EXPS END                      ( Ast.Let (DECS, EXPS) ) 
        | LET DECS IN END                           ( Ast.Let (DECS, nil) )

EXPS    : EXP                                       ( [EXP] )
        | EXP SEMICOLON EXPS                        ( EXP :: EXPS )

LVALUE  : ID                                        ( Ast.Id ID )
        | LVALUE LBRACKETS EXP RBRACKETS            ( Ast.Subscript (LVALUE, EXP) )
        | LVALUE DOT ID                             ( Ast.Field (LVALUE, ID) )

RECORDFIELDDEC
        : ID EQUALS EXP                             ( [(ID, EXP)] )
        | ID EQUALS EXP COMMA RECORDFIELDDEC        ( (ID, EXP) :: RECORDFIELDDEC )

DECS    : TYPEDEC                                   ( Ast.TyDec TYPEDEC )
        | VARDEC                                    ( Ast.VDec VARDEC )
        | FUNDEC                                    ( Ast.FDec FUNDEC )

TYPEDEC : TYPE ID EQUALS ID                         ( Ast.TypeAssignment (ID1, ID2) )
        | TYPE ID EQUALS ARRAY OF ID                ( Ast.ArrayType (ID1, ID2) )
        | TYPE ID EQUALS LBRACES                    
          RECORDFIELDCREATE RBRACES                 ( Ast.RecordType (ID, RECORDFIELDCREATE) )

RECORDFIELDCREATE 
        : ID COLON ID                               ( [(ID1, ID2)] )
        | ID COLON ID SEMICOLON RECORDFIELDCREATE   ( (ID1, ID2) :: RECORDFIELDCREATE )

FUNDEC  : FUNCTION ID LPAREN RECORDFIELDCREATE      
          RPAREN EQUALS EXP                         ( Ast.Fun (ID, RECORDFIELDCREATE, EXP) )
        | FUNCTION ID LPAREN RPAREN EQUALS EXP      ( Ast.Fun (ID, [], EXP) )
        | FUNCTION ID LPAREN RECORDFIELDCREATE 
          RPAREN COLON ID EQUALS EXP                ( Ast.FunType (ID1, RECORDFIELDCREATE, ID2, EXP) )
        | FUNCTION ID LPAREN RPAREN COLON ID        
          EQUALS EXP                                ( Ast.FunType (ID1, [], ID2, EXP) )

VARDEC  : VAR ID ASSIGN EXP                         ( Ast.Var (ID, EXP) )
        | VAR ID COLON ID ASSIGN EXP                ( Ast.VarType (ID1, ID2, EXP) )

OPERATOR 
        : PLUS                                      ( Ast.Plus )
        | MINUS                                     ( Ast.Minus )
        | MULTIPLY                                  ( Ast.Multiply )
        | DIVIDE                                    ( Ast.Divide )
        | GREATER                                   ( Ast.Greater )
        | LESS                                      ( Ast.Less )
        | EQUALS                                    ( Ast.Equals )
        | NOTEQUAL                                  ( Ast.NotEqual )
        | LESSEQUAL                                 ( Ast.LessEqual )
        | GREATEREQUAL                              ( Ast.GreaterEqual )