(* This file provides glue code for building the pretty printer using the parser and lexer specified 
   in prettyPrinter.lex and prettyPrinter.grm. *)

(* Creating the lexer and parser for our grammar using functors generated by ML-Lex and ML-Yacc
    from the descriptions provided in the corresponding .lex and .grm files *)
structure PrettyPrinterLrVals =
    PrettyPrinterLrValsFun ( structure Token = LrParser.Token )
structure PrettyPrinterLex = 
    PrettyPrinterLexFun ( structure Tokens = PrettyPrinterLrVals.Tokens )
structure PrettyPrinterParser =
    JoinWithArg ( structure ParserData = PrettyPrinterLrVals.ParserData
                  structure Lex = PrettyPrinterLex
                  structure LrParser = LrParser )

structure PrettyPrinter = struct
    
    exception PrettyPrinterError;
    
    fun printTree = List.app (fn x => (printStmt x; TextIO.print "\n"))
    and printStmt stmt (var, exp) = (TextIO.print (var ^ " = "); printExp exp)
    and printExp (T term) = printTerm term |
        printExp (S (term, exp)) = (printTerm term; TextIO.print (" + "); printExp exp)
    and printTerm (F factor) = printFactor factor |
        printTerm (P (factor, term)) = (printFactor factor; TextIO.print (" * "); printExp term)
    and printFactor (V str) = TextIO.print str |
        printFactor (Const const) = TextIO.print (Int.toString const);

    fun prettyPrint fileName =
        let val inStream = TextIO.openIn fileName;
            val grab n => if TextIO.endOfStream inStream then "" else TextIO.inputN (inStream, n);
            val printError (msg, line, col) = print (fileName ^ "[" ^ Int.toString line ^ ":" 
                                                  ^ Int.toString col ^ "] " ^ msg ^ "\n");
            val (tree, rem) = PiParser.parse (15, (PiParser.makeLexer grab fileName), printError, fileName);
            handle PrettyPrinterParser.ParseError => raise PrettyPinterError;
            (* Close the source program file *)
            val _ = TextIO.closeIn inStream;
        in printTree tree end

end;